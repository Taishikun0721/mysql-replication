## ロックについて

### なんのために必要か？
共有レコードに対しての変更に対して整合性を保持するために存在する。

### ロックの種類
- 論理的なロック、ロックの方針
 - 楽観的ロック
  - あくまでアプリケーションレベルでの制御となる。具体的にはバージョンカラムをテーブルに設定して、updateの時にそのカラムの値を更新する。
    トランザクションが並列に走っている時に、更新前のバージョンの数値が変更されていたら他のトランザクションが変更を実施した富なし例外を発行する
 - 悲観的ロック

- 物理的なロック
 - 占有ロック(排他ロック)
 - 共有ロック

### 3種類の不都合な現象

- Dirty Reads
 - commitされる前の変更を見る事ができる
- Non Repetable Reads
 - commitされたレコードへの更新が同一トランザクション内で見る事ができる
- Phantom reads
 - commitされたテーブルへのinsertが同一トランザクション内で見る事ができる

詳しくは[こちら](https://qiita.com/momotaro98/items/ad859ec2934ee98540fb)

### トランザクション分離レベル

#### READ UNCOMMITED
- commitしていない変更も同じトランザクションから読み込む事ができる

#### READ COMMITED
- commitをした変更を読み込むことができる

ACID特性の一つである、Isolation(ACIDのI)に関数指標の一つで、トランザクション毎にどのくらい分離されているか
レベルを設定できる。

#### REPETAABLE-READ
InnoDBのデフォルトのトランザクション分離レベル。
このレベルを使えば、他のトランザクションの更新に影響される事はないが、ロックをとっているわけではないのでlost updateを防ぐことはできない。

- Lost Updateとは?
めちゃ簡単に言うと後勝ちで更新される性質の事を言う
2つのトランザクションがあり、片方のトランザクションでselectで取得したレコードを別トランザクションが更新してしまった場合
`REPETABLE-READ`の場合は、別トランザクションでの変更を読み込まないので、他のトランザクションで値を読み込んでいる事に気づく事ができない。
そのため、他のトランザクションの変更をさらに上書きしてcommitしてしまう可能性がある。

■ 注意点
- `REPETABLE READ`は`non-locking read`と`locking read`で読み込みの挙動が変わる。
`locking read`の場合は、他のトランザクションのcommitした値を読み取る様になるので、その値が重要な機能を作るのであれば、まず最初スナップショットが作成されるタイミングでロックを取っておかないと、並列で走るトランザクションで不整合が起きる可能性がある。

[参考](https://techblog.kayac.com/repeatable_read.html)

#### SERIALIZABLE
selectした行に対して共有ロックが確実にかかるレベル。
Lost Updateを防ぐことができる

### 一貫性読み取り
スナップショットを利用して、他のトランザクションに影響を受けずにある時点のデータに基づいてクエリ結果を表示する読み取り動作の事
トランザクションの中では、一貫性読み取りが適応されるより前のデータの状態が表示される。






