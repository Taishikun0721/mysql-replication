## バイナリログを使ってリカバリーをする方法(ポジション指定バージョン)

### PITR(Auroraが提供するポイントインタイムリカバリー)と何が違うのか？
- PITRは任意の時間に戻ることはできるが、クリティカルなミスが発生した場合にその特定の場所に戻れるとは限らない
  ただバイナリログのポジションを使ったリカバリーを使用すれば、特定の位置をピンポイントで狙ってバックアップできる。

- とはいえ、バイナリログを直接視認して適応するというのは非常にデリケートな作業なので、実際にはPITRで時間レベルでリカバリーをした方安全性が高い
  そのため内部的な仕組みを知るものという位置付けで実施する

- 間違えた位置から適応すると整合性を損なう危険性がある。
- トランザクションの区切りで、ポイントを抽出しないと整合性を損なう危険性がある

どうしてもやるなら、書き込みは完全に遮断して、ダブルチェックなどの体制がないと厳しいと思われる

### 手順

まず`mysqlbinlog`というコマンドが使えないと行けないので、デフォルトで使用ができるdebian系のMySQLイメージをDockerfileに指定する。

例えば、test_dbのusersテーブルに↓のようなデータが存在していたが、削除してしまったとする

```
mysql> select * from users;
+------+
| id   |
+------+
|    1 |
| 1000 |
+------+
```

```
// whereをつけ忘れた...
DELETE FROM users;
```

上記のような場合、当然データは全て消えてしまう。
ただしバイナリログが存在していれば元に戻すことはできる

```
show binary logs;
```

バイナリログのファイル名と、現在のポイントを確認する

```
+---------------+-----------+-----------+
| Log_name      | File_size | Encrypted |
+---------------+-----------+-----------+
| binlog.000001 |   2994206 | No        |
| binlog.000002 |      1146 | No        |
+---------------+-----------+-----------+
2 rows in set (0.01 sec)
```

その後に実際のバイナリログの中身を確認する。

```
mysqlbinlog --base64-output=DECODE-ROWS -vv /var/lib/mysql/{バイナリログファイル名}
```

`--base64-output=DECODE-ROWS` => 実際にはバイナリ形式で出力されるのでデコードして読めるようにする
`-vv` => 詳細情報を出力するオプション

そうするとログがどこまで実行されているかを調べる事ができるのでメモをする。具体的には

```
# at 911
```
と書いている時点が、開始位置になるので実際にSQLとして出力した部分を指定する。

```
mysqlbinlog --start-position=911 --stop-position=1186 /var/lib/mysql/b4a752ae3149-bin.000003 > recovery.sql
```

こうすることで、リカバリ用のSQLファイルを作成する事ができる。
あとはこれをrestore用に新しく建てた環境に適応する。

```
mysql -u {ユーザー名} -p{パスワード} < recovery.sql
```

ここまで実施すれば元の状態に戻せているはず。
尚、公式では`--start-datetime`などの時間を使って、バイナリログのセグメントを区切るのは非推奨で
理由はトランザクションの境目を正確に判別できなくなるから。

https://dev.mysql.com/doc/refman/8.0/ja/point-in-time-recovery-positions.html

